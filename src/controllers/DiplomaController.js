import diplomaModel from '../models/Diploma.js';
import { PrismaClient } from '@prisma/client';
import crypto from 'crypto';

const prisma = new PrismaClient();

const DiplomasController = {
  // üü¢ Cr√©ation de dipl√¥mes par universit√©
  async creerDiplomes (req, res)  {
    try {
      const { anneeId, titreDiplome, typeDiplome, etudiants } = req.body;
      console.log("partie Controller: ");
      console.log("üì© Requ√™te re√ßue avec :", req.body);
      console.log("Type de etudiants:", typeof etudiants);
      console.log("Contenu de etudiants:", etudiants);
      console.log("Premier √©l√©ment:", etudiants[0]);
      if (!anneeId || !titreDiplome || !typeDiplome || !etudiants) {
        return res.status(400).json({ success: false, message: "Champs requis manquants" });
      }

      const result = await diplomaModel.creerDiplomesPourEtudiants(anneeId, titreDiplome, typeDiplome, etudiants);

      if (result.length === 0) {
        return res.status(400).json({ success: false, message: "Aucun dipl√¥me n'a pu √™tre cr√©√©. V√©rifiez les donn√©es des √©tudiants." });
      }
      
      res.status(200).json({ success: true, diplomeIds: result.map(d => d.id) });
    } catch (error) {
      console.error("Erreur cr√©ation dipl√¥mes:", error);
      res.status(500).json({ success: false, message: "Erreur serveur" });
    }
  }, 

  // üîç Dipl√¥mes √† valider
  async getDiplomasToValidate(req, res) {
    try {
      const { universityId } = req.params;
      const diplomas = await diplomaModel.getDiplomasToValidateService(universityId);
      res.json(diplomas);
    } catch (error) {
      console.error('Erreur:', error);
      res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des dipl√¥mes.' });
    }
  },

  // ‚úÖ Valider un dipl√¥me
  async validateDiploma(req, res) {
    try {
      const { diplomaId } = req.params;
      const diploma = await diplomaModel.validateDiplomaService(diplomaId);
      res.json({
        message: `Dipl√¥me ${diploma.nom} valid√© avec succ√®s !`,
        diploma
      });
    } catch (error) {
      console.error('Erreur de validation:', error);
      res.status(500).json({ message: 'Erreur lors de la validation du dipl√¥me.' });
    }
  },

  // ‚úÖ Valider tous les dipl√¥mes d'une universit√©
  async validateAllDiplomas(req, res) {
    try {
      const { universityId } = req.params;
      const result = await diplomaModel.validateAllDiplomasService(universityId);
      res.json({ message: `${result.count} dipl√¥mes valid√©s avec succ√®s !` });
    } catch (error) {
      console.error('Erreur bulk validation:', error);
      res.status(500).json({ message: 'Erreur lors de la validation de tous les dipl√¥mes.' });
    }
  },

  // üéì Dipl√¥mes valid√©s
  async getValidatedDiplomas(req, res) {
    try {
      const { universityId } = req.params;
      const diplomas = await diplomaModel.getValidatedDiplomasService(universityId);
      res.json(diplomas);
    } catch (error) {
      console.error('Erreur dipl√¥mes valid√©s:', error);
      res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des dipl√¥mes valid√©s.' });
    }
  },


  async rejectDiploma(req, res) {
    const { diplomaId } = req.params;
    try {
      const diploma = await prisma.diplome.delete({
        where: { id: parseInt(diplomaId) }
      });
      if (!diploma) {
        return res.status(404).json({ error: 'Dipl√¥me non trouv√©' });
      }
      res.status(200).json({ message: 'Dipl√¥me rejet√© avec succ√®s' });
    } catch (error) {
      console.error('Erreur lors du rejet du dipl√¥me :', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  },

 // Dans DiplomaController.js
async creerDiplomesEcole(req, res) {
  try {
    console.log("Received request body:", req.body);
    
    const { anneeId, titreDiplome, diplomeType, etudiants, etablissement } = req.body;

    // Enhanced validation
    if (!anneeId || !titreDiplome || !diplomeType || !etablissement) {
      return res.status(400).json({ 
        success: false, 
        message: "Missing required fields" 
      });
    }

    if (!etudiants || !Array.isArray(etudiants) || etudiants.length === 0) {
      return res.status(400).json({ 
        success: false, 
        message: "Etudiants array is required and must not be empty" 
      });
    }

    const result = [];
    const errors = [];

    // Transaction
    await prisma.$transaction(async (prisma) => {
      for (const { idEtudiantEcole } of etudiants) {
        try {
          // Verify student exists with all required relations
          const etudiant = await prisma.etudiantEcole.findUnique({
            where: { idEtudiantEcole: Number(idEtudiantEcole) },
            include: { 
              cursus: {
                include: {
                  formation: true,
                  annee: true
                }
              } 
            }
          });

          if (!etudiant) {
            errors.push({ idEtudiantEcole, error: "√âtudiant non trouv√©" });
            continue;
          }

          if (!etudiant.cursus || etudiant.cursus.length === 0) {
            errors.push({ idEtudiantEcole, error: "L'√©tudiant n'a pas de cursus" });
            continue;
          }

          const currentCursus = etudiant.cursus.find(c => c.annee.id === anneeId);
          if (!currentCursus) {
            errors.push({ idEtudiantEcole, error: "L'√©tudiant n'est pas inscrit dans l'ann√©e sp√©cifi√©e" });
            continue;
          }

          if (!currentCursus.formation) {
            errors.push({ idEtudiantEcole, error: "La formation de l'√©tudiant n'est pas d√©finie" });
            continue;
          }

          // Create diploma
          const diplome = await prisma.diplomeEcole.create({
            data: {
              diplomaHash: crypto.randomBytes(32).toString('hex'),
              etablissement,
              studentName: `${etudiant.nom} ${etudiant.prenom}`,
              birthDate: etudiant.dateNaissance || new Date(),
              diplomaTitle: titreDiplome,
              diplomaType: diplomeType,  // Fixed: using the correct variable name
              dateOfIssue: new Date(),
              specialite: currentCursus.formation.nomFormation,
              etudiantEcoleId: etudiant.idEtudiantEcole
            }
          });

          result.push(diplome);
        } catch (error) {
          console.error(`Error creating diploma for student ${idEtudiantEcole}:`, error);
          errors.push({ idEtudiantEcole, error: error.message });
        }
      }
    });

    if (result.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Aucun dipl√¥me cr√©√©",
        errors: errors.length > 0 ? errors : ["Unknown error occurred"]
      });
    }

    res.json({
      success: true,
      count: result.length,
      diplomes: result,
      warnings: errors.length > 0 ? { errors } : undefined
    });
  } catch (error) {
    console.error("Server error in creerDiplomesEcole:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la cr√©ation des dipl√¥mes",
      error: error.message
    });
  }
},
  async demanderDiplome(req, res) {
    try {
      // 1. Trouver l'√©tudiant correspondant
      const etudiant = await prisma.etudiant.findFirst({
        where: {
          OR: [
            { nom: { contains: req.body.studentName.split(' ')[0] } },
            { prenom: { contains: req.body.studentName.split(' ')[1] } }
          ]
        }
      });
  
      if (!etudiant) {
        return res.status(404).json({ message: "√âtudiant non trouv√©" });
      }
  
      // 2. Trouver le cursus pour la sp√©cialit√©
      const cursus = await prisma.cursusUniversitaire.findFirst({
        where: {
          idEtudiant: etudiant.idEtudiant,
          specialite: req.body.speciality
        }
      });
  
      // 3. Calculer le hash COMME √Ä LA CR√âATION
      const dataToHash = [
        etudiant.idEtudiant,
        req.body.diplomaTitle,
        req.body.diplomaType,
        `${etudiant.nom} ${etudiant.prenom}`,
        new Date(req.body.birthDate).toISOString(),
        cursus?.specialite || req.body.speciality
      ].join('|');
  
      const diplomaHash = crypto.createHash('sha256').update(dataToHash).digest('hex');
  
      // 4. Recherche
      const existingDiploma = await prisma.diplome.findFirst({
        where: { diplomaHash }
      });
  
      if (existingDiploma) {
        const verificationLink = `https://CertifyMe.com/verifier-diplome/${diplomaHash}`;
        
        // Sauvegarder dans l'historique
        await prisma.historiqueVerification.create({
          data: {
              idEtudiant: etudiant.idEtudiant,
              nomEtudiant: `${etudiant.nom} ${etudiant.prenom}`,
              lienVerification: verificationLink,
              titreDiplome: existingDiploma.diplomaTitle,
              etablissement: existingDiploma.etablissement,
              dateDemande: new Date(),
              dateDernierAcces: new Date() // Initialis√© √† maintenant
          }
      });

        return res.json({
          success: true,
          message: "Dipl√¥me trouv√© dans notre syst√®me!",
          verificationMessage: `Pour v√©rifier la validit√© de votre dipl√¥me √† tout moment, voici votre lien permanent:`,
          verificationLink: verificationLink,
          verificationRemarque: `ce lien doit √™tre v√©rifi√© sur la plateforme CertifyMe . un clic sur ce lien n'acc√©dera √† aucune page de v√©rification`,
          diplomaInfo: {
            title: existingDiploma.diplomaTitle,
            date: existingDiploma.dateOfIssue,
            establishment: existingDiploma.etablissement
          }
        });
      }
  
      return res.status(404).json({
        success: false,
        message: "Aucun dipl√¥me trouv√© avec ces informations.",
        suggestion: "Votre demande a √©t√© enregistr√©e. Vous recevrez une notification lorsque le dipl√¥me sera disponible."
      });
  
    } catch (error) {
      console.error('Erreur lors de la v√©rification du dipl√¥me:', {
        error: error.message,
        stack: error.stack,
        requestBody: req.body
      });
      res.status(500).json({ 
        success: false,
        message: "Erreur serveur lors de la v√©rification",
        technicalDetails: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  },
  // Dans votre controller diplome.js
  async verifierDiplome(req, res) {
    try {
      const { hash } = req.params;
      
      const diploma = await prisma.diplome.findUnique({
        where: { diplomaHash: hash },
        select: {
          diplomaTitle: true,
          studentName: true,
          etablissement: true,
          dateOfIssue: true,
          speciality: true
        }
      });
  
      if (!diploma) {
        return res.status(404).json({ 
          success: false,
          message: "Aucun dipl√¥me trouv√© avec cet identifiant" 
        });
      }
  
      return res.json({
        success: true,
        ...diploma
      });
    } catch (error) {
      console.error('Erreur v√©rification:', error);
      res.status(500).json({ 
        success: false,
        message: "Erreur serveur" 
      });
    }
  },
  async getHistorique(req, res) {
    try {
      console.log('Requ√™te historique re√ßue pour user:', req.user.idEtudiant);
      
      if (!req.user?.idEtudiant) {
        console.warn('Acc√®s non autoris√© - idEtudiant manquant');
        return res.status(401).json({ 
          success: false, 
          message: "Authentification requise" 
        });
      }
  
      const historique = await prisma.historiqueVerification.findMany({
        where: { idEtudiant: req.user.idEtudiant },
        distinct: ['titreDiplome'],
        orderBy: { dateDemande: 'desc' }
      });
  
      console.log(`Historique trouv√©: ${historique.length} entr√©es`);
  
      // R√©ponse explicite en JSON
      res.setHeader('Content-Type', 'application/json');
      res.status(200).json({
        success: true,
        historique: historique.map(item => ({
          id: item.id,
          titreDiplome: item.titreDiplome,
          lienVerification: item.lienVerification,
          etablissement: item.etablissement,
          dateDemande: item.dateDemande
        }))
      });
  
    } catch (error) {
      console.error('Erreur getHistorique:', {
        error: error.message,
        stack: error.stack,
        user: req.user
      });
      res.status(500).json({
        success: false,
        message: "Erreur serveur",
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
}
export default DiplomasController;
