import diplomaModel from '../models/Diploma.js';
import { PrismaClient } from '@prisma/client';
import crypto from 'crypto';

const prisma = new PrismaClient();

const DiplomasController = {
  // üü¢ Cr√©ation de dipl√¥mes par universit√©
  async creerDiplomes (req, res)  {
    try {
      const { anneeId, titreDiplome, typeDiplome, etudiants } = req.body;
      console.log("partie Controller: ");
      console.log("üì© Requ√™te re√ßue avec :", req.body);
      console.log("Type de etudiants:", typeof etudiants);
      console.log("Contenu de etudiants:", etudiants);
      console.log("Premier √©l√©ment:", etudiants[0]);
      if (!anneeId || !titreDiplome || !typeDiplome || !etudiants) {
        return res.status(400).json({ success: false, message: "Champs requis manquants" });
      }

      const result = await diplomaModel.creerDiplomesPourEtudiants(anneeId, titreDiplome, typeDiplome, etudiants);

      if (result.length === 0) {
        return res.status(400).json({ success: false, message: "Aucun dipl√¥me n'a pu √™tre cr√©√©. V√©rifiez les donn√©es des √©tudiants." });
      }
      
      res.status(200).json({ success: true, diplomeIds: result.map(d => d.id) });
    } catch (error) {
      console.error("Erreur cr√©ation dipl√¥mes:", error);
      res.status(500).json({ success: false, message: "Erreur serveur" });
    }
  }, 

  // üîç Dipl√¥mes √† valider
  async getDiplomasToValidate(req, res) {
    try {
      const { universityId } = req.params;
      const diplomas = await diplomaModel.getDiplomasToValidateService(universityId);
      res.json(diplomas);
    } catch (error) {
      console.error('Erreur:', error);
      res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des dipl√¥mes.' });
    }
  },

  // ‚úÖ Valider un dipl√¥me
  async validateDiploma(req, res) {
    try {
      const { diplomaId } = req.params;
      const diploma = await diplomaModel.validateDiplomaService(diplomaId);
      res.json({
        message: `Dipl√¥me ${diploma.nom} valid√© avec succ√®s !`,
        diploma
      });
    } catch (error) {
      console.error('Erreur de validation:', error);
      res.status(500).json({ message: 'Erreur lors de la validation du dipl√¥me.' });
    }
  },

  // ‚úÖ Valider tous les dipl√¥mes d'une universit√©
  async validateAllDiplomas(req, res) {
    try {
      const { universityId } = req.params;
      const result = await diplomaModel.validateAllDiplomasService(universityId);
      res.json({ message: `${result.count} dipl√¥mes valid√©s avec succ√®s !` });
    } catch (error) {
      console.error('Erreur bulk validation:', error);
      res.status(500).json({ message: 'Erreur lors de la validation de tous les dipl√¥mes.' });
    }
  },

  // üéì Dipl√¥mes valid√©s
  async getValidatedDiplomas(req, res) {
    try {
      const { universityId } = req.params;
      const diplomas = await diplomaModel.getValidatedDiplomasService(universityId);
      res.json(diplomas);
    } catch (error) {
      console.error('Erreur dipl√¥mes valid√©s:', error);
      res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des dipl√¥mes valid√©s.' });
    }
  },


  async rejectDiploma(req, res) {
    const { diplomaId } = req.params;
    try {
      const diploma = await prisma.diplome.delete({
        where: { id: parseInt(diplomaId) }
      });
      if (!diploma) {
        return res.status(404).json({ error: 'Dipl√¥me non trouv√©' });
      }
      res.status(200).json({ message: 'Dipl√¥me rejet√© avec succ√®s' });
    } catch (error) {
      console.error('Erreur lors du rejet du dipl√¥me :', error);
      res.status(500).json({ error: 'Erreur serveur' });
    }
  },
  // Dipl√¥mes non valid√©s pour une √©cole
async getEcoleDiplomasToValidate(req, res) {
  try {
    const { ecoleId } = req.params;
    const diplomas = await diplomaModel.getEcoleDiplomasToValidateService(ecoleId);
    res.json(diplomas);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
},

// Valider un dipl√¥me d'√©cole
async validateEcoleDiploma(req, res) {
  try {
    const { diplomaId } = req.params;
    const diploma = await diplomaModel.validateEcoleDiplomaService(diplomaId);
    res.json({
      message: `Dipl√¥me ${diploma.studentName} valid√© avec succ√®s !`,
      diploma
    });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la validation du dipl√¥me.' });
  }
},

// Valider tous les dipl√¥mes d'une √©cole
async validateAllEcoleDiplomas(req, res) {
  try {
    const { ecoleId } = req.params;
    const result = await diplomaModel.validateAllEcoleDiplomasService(ecoleId);
    res.json({ message: `${result.count} dipl√¥mes valid√©s avec succ√®s !` });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la validation des dipl√¥mes.' });
  }
},

// Dipl√¥mes valid√©s pour une √©cole
async getValidatedEcoleDiplomas(req, res) {
  try {
    const { ecoleId } = req.params;
    const diplomas = await diplomaModel.getValidatedEcoleDiplomasService(ecoleId);
    res.json(diplomas);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
},

// Rejeter un dipl√¥me d'√©cole
async rejectEcoleDiploma(req, res) {
  try {
    const { diplomaId } = req.params;
    await diplomaModel.rejectEcoleDiplomaService(diplomaId);
    res.json({ message: 'Dipl√¥me rejet√© avec succ√®s.' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors du rejet du dipl√¥me.' });
  }
},

 // Dans DiplomaController.js
async creerDiplomesEcole(req, res) {
  try {
    console.log("Received request body:", req.body);
    
    const { anneeId, titreDiplome, diplomeType, etudiants, etablissement } = req.body;

    // Enhanced validation
    if (!anneeId || !titreDiplome || !diplomeType || !etablissement) {
      return res.status(400).json({ 
        success: false, 
        message: "Missing required fields" 
      });
    }

    if (!etudiants || !Array.isArray(etudiants) || etudiants.length === 0) {
      return res.status(400).json({ 
        success: false, 
        message: "Etudiants array is required and must not be empty" 
      });
    }

    const result = [];
    const errors = [];

    // Transaction
    await prisma.$transaction(async (prisma) => {
      for (const { idEtudiantEcole } of etudiants) {
        try {
          // Verify student exists with all required relations
          const etudiant = await prisma.etudiantEcole.findUnique({
            where: { idEtudiantEcole: Number(idEtudiantEcole) },
            include: { 
              cursus: {
                include: {
                  formation: true,
                  annee: true
                }
              } 
            }
          });

          if (!etudiant) {
            errors.push({ idEtudiantEcole, error: "√âtudiant non trouv√©" });
            continue;
          }

          if (!etudiant.cursus || etudiant.cursus.length === 0) {
            errors.push({ idEtudiantEcole, error: "L'√©tudiant n'a pas de cursus" });
            continue;
          }

          const currentCursus = etudiant.cursus.find(c => c.annee.id === anneeId);
          if (!currentCursus) {
            errors.push({ idEtudiantEcole, error: "L'√©tudiant n'est pas inscrit dans l'ann√©e sp√©cifi√©e" });
            continue;
          }

          if (!currentCursus.formation) {
            errors.push({ idEtudiantEcole, error: "La formation de l'√©tudiant n'est pas d√©finie" });
            continue;
          }

          // Create diploma
          const diplome = await prisma.diplomeEcole.create({
            data: {
              diplomaHash: crypto.createHash('sha256').update([
  etudiant.idEtudiantEcole,
  titreDiplome,
  `${etudiant.nom} ${etudiant.prenom}`,
  new Date(etudiant.dateNaissance || new Date()).toISOString(),
  currentCursus.formation.nomFormation
].join('|')).digest('hex'),
              etablissement,
              studentName: `${etudiant.nom} ${etudiant.prenom}`,
              birthDate: etudiant.dateNaissance || new Date(),
              diplomaTitle: titreDiplome,
              diplomaType: diplomeType,  // Fixed: using the correct variable name
              dateOfIssue: new Date(),
              specialite: currentCursus.formation.nomFormation,
              etudiantEcoleId: etudiant.idEtudiantEcole
            }
          });

          result.push(diplome);
        } catch (error) {
          console.error(`Error creating diploma for student ${idEtudiantEcole}:`, error);
          errors.push({ idEtudiantEcole, error: error.message });
        }
      }
    });

    if (result.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Aucun dipl√¥me cr√©√©",
        errors: errors.length > 0 ? errors : ["Unknown error occurred"]
      });
    }

    res.json({
      success: true,
      count: result.length,
      diplomes: result,
      warnings: errors.length > 0 ? { errors } : undefined
    });
  } catch (error) {
    console.error("Server error in creerDiplomesEcole:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la cr√©ation des dipl√¥mes",
      error: error.message
    });
  }
},
  async demanderDiplome(req, res) {
    try {
      // 1. Trouver l'√©tudiant correspondant
      const etudiant = await prisma.etudiant.findFirst({
        where: {
          OR: [
            { nom: { contains: req.body.studentName.split(' ')[0] } },
            { prenom: { contains: req.body.studentName.split(' ')[1] } }
          ]
        }
      });
  
      if (!etudiant) {
        return res.status(404).json({ message: "√âtudiant non trouv√©" });
      }
  
      // 2. Trouver le cursus pour la sp√©cialit√©
      const cursus = await prisma.cursusUniversitaire.findFirst({
        where: {
          idEtudiant: etudiant.idEtudiant,
          specialite: req.body.speciality
        }
      });
  
      // 3. Calculer le hash COMME √Ä LA CR√âATION
      const dataToHash = [
        etudiant.idEtudiant,
        req.body.diplomaTitle,
        `${etudiant.nom} ${etudiant.prenom}`,
        new Date(req.body.birthDate).toISOString(),
        cursus?.specialite || req.body.speciality
      ].join('|');
  
      const diplomaHash = crypto.createHash('sha256').update(dataToHash).digest('hex');
  
      // 4. Recherche
      const existingDiploma = await prisma.diplome.findFirst({
        where: { diplomaHash }
      });
  //+ verfiication bc 


      if (existingDiploma) {
        const verificationLink = `https://CertifyMe.com/verifier-diplome/${diplomaHash}`;
        
        // Sauvegarder dans l'historique
        await prisma.historiqueVerification.create({
          data: {
              idEtudiant: etudiant.idEtudiant,
              nomEtudiant: `${etudiant.nom} ${etudiant.prenom}`,
              lienVerification: verificationLink,
              titreDiplome: existingDiploma.diplomaTitle,
              etablissement: existingDiploma.etablissement,
              dateDemande: new Date(),
              dateDernierAcces: new Date() // Initialis√© √† maintenant
          }
      });

        return res.json({
          success: true,
          message: "Dipl√¥me trouv√© dans notre syst√®me!",
          verificationMessage: `Pour v√©rifier la validit√© de votre dipl√¥me √† tout moment, voici votre lien permanent:`,
          verificationLink: verificationLink,
          verificationRemarque: `ce lien doit √™tre v√©rifi√© sur la plateforme CertifyMe . un clic sur ce lien n'acc√©dera √† aucune page de v√©rification`,
          diplomaInfo: {
            title: existingDiploma.diplomaTitle,
            date: existingDiploma.dateOfIssue,
            establishment: existingDiploma.etablissement
          }
        });
      }
  
      return res.status(404).json({
        success: false,
        message: "Aucun dipl√¥me trouv√© avec ces informations.",
        suggestion: "Votre demande a √©t√© enregistr√©e. Vous recevrez une notification lorsque le dipl√¥me sera disponible."
      });
  
    } catch (error) {
      console.error('Erreur lors de la v√©rification du dipl√¥me:', {
        error: error.message,
        stack: error.stack,
        requestBody: req.body
      });
      res.status(500).json({ 
        success: false,
        message: "Erreur serveur lors de la v√©rification",
        technicalDetails: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  },
  // Dans votre controller diplome.js
  async verifierDiplome(req, res) {
    try {
      const { hash } = req.params;
      
      const diploma = await prisma.diplome.findUnique({
        where: { diplomaHash: hash },
        select: {
          diplomaTitle: true,
          studentName: true,
          etablissement: true,
          dateOfIssue: true,
          speciality: true
        }
      });
  
      if (!diploma) {
        return res.status(404).json({ 
          success: false,
          message: "Aucun dipl√¥me trouv√© avec cet identifiant" 
        });
      }
  
      return res.json({
        success: true,
        ...diploma
      });
    } catch (error) {
      console.error('Erreur v√©rification:', error);
      res.status(500).json({ 
        success: false,
        message: "Erreur serveur" 
      });
    }
  },
  // Fonction pour demander un dipl√¥me d'√©cole
async demanderDiplomeEcole(req, res) {
    try {
        // 1. Trouver l'√©tudiant correspondant
        const etudiant = await prisma.etudiantEcole.findFirst({
            where: {
                OR: [
                    { nom: { contains: req.body.studentName.split(' ')[0] } },
                    { prenom: { contains: req.body.studentName.split(' ')[1] } }
                ]
            }
        });

        if (!etudiant) {
            return res.status(404).json({ message: "√âtudiant non trouv√©" });
        }

        // 2. Calculer le hash
        const dataToHash = [
            etudiant.idEtudiantEcole,
            req.body.diplomaTitle,
            `${etudiant.nom} ${etudiant.prenom}`,
            new Date(req.body.birthDate).toISOString(),
            req.body.speciality
        ].join('|');

        console.log("Donn√©es pour hash (V√âRIFICATION):", {
  idEtudiant: etudiant.idEtudiantEcole,
  titreDiplome: req.body.diplomaTitle,
  nomComplet: `${etudiant.nom} ${etudiant.prenom}`,
  dateNaissance: new Date(req.body.birthDate).toISOString(),
  specialite: req.body.speciality,
  chaineComplete: dataToHash
});

        const diplomaHash = crypto.createHash('sha256').update(dataToHash).digest('hex');
        
        // 3. Recherche du dipl√¥me
        const existingDiploma = await prisma.diplomeEcole.findFirst({
            where: { diplomaHash }
        });

        if (existingDiploma) {
            const verificationLink = `https://CertifyMe.com/verifier-diplome-ecole/${diplomaHash}`;
            
            // Sauvegarder dans l'historique
            await prisma.historiqueVerification.create({
                data: {
                    idEtudiant: etudiant.idEtudiantEcole,
                    nomEtudiant: `${etudiant.nom} ${etudiant.prenom}`,
                    lienVerification: verificationLink,
                    titreDiplome: existingDiploma.diplomaTitle,
                    etablissement: existingDiploma.etablissement,
                    dateDemande: new Date(),
                    dateDernierAcces: new Date()
                }
            });

            return res.json({
                success: true,
                message: "Dipl√¥me d'√©cole trouv√© dans notre syst√®me!",
                verificationMessage: `Pour v√©rifier la validit√© de votre dipl√¥me √† tout moment, voici votre lien permanent:`,
                verificationLink: verificationLink,
                verificationRemarque: `Ce lien doit √™tre v√©rifi√© sur la plateforme CertifyMe`,
                diplomaInfo: {
                    title: existingDiploma.diplomaTitle,
                    date: existingDiploma.dateOfIssue,
                    establishment: existingDiploma.etablissement,
                    mention: existingDiploma.mention
                }
            });
        }

        return res.status(404).json({
            success: false,
            message: "Aucun dipl√¥me d'√©cole trouv√© avec ces informations."
        });

    } catch (error) {
        console.error('Erreur lors de la v√©rification du dipl√¥me:', error);
        res.status(500).json({ 
            success: false,
            message: "Erreur serveur lors de la v√©rification"
        });
    }
},

// Fonction pour v√©rifier un dipl√¥me d'√©cole
async verifierDiplomeEcole(req, res) {
    try {
        const { hash } = req.params;
        
        const diploma = await prisma.diplomeEcole.findUnique({
            where: { diplomaHash: hash },
            select: {
                diplomaTitle: true,
                studentName: true,
                etablissement: true,
                dateOfIssue: true,
                specialite: true,
                mention: true
            }
        });

        if (!diploma) {
            return res.status(404).json({ 
                success: false,
                message: "Aucun dipl√¥me d'√©cole trouv√© avec cet identifiant" 
            });
        }

        return res.json({
            success: true,
            ...diploma
        });
    } catch (error) {
        console.error('Erreur v√©rification dipl√¥me √©cole:', error);
        res.status(500).json({ 
            success: false,
            message: "Erreur serveur" 
        });
    }
},

async getEcoleDiplomes(req, res) {
  try {
    const { ecoleId } = req.params;
    const { annee } = req.query;

    const whereClause = {
      etudiantEcole: {
        cursus: {
          some: {
            annee: {
              ecoleId: parseInt(ecoleId)
            }
          }
        }
      }
    };

    if (annee) {
      whereClause.dateOfIssue = {
        gte: new Date(`${annee}-01-01`),
        lte: new Date(`${annee}-12-31`)
      };
    }

    const diplomes = await prisma.diplomeEcole.findMany({
      where: whereClause,
      orderBy: { dateOfIssue: 'desc' },
      include: {
        etudiantEcole: {
          select: {
            nom: true,
            prenom: true,
            matricule: true
          }
        }
      }
    });

    res.json(diplomes);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
},


async deleteEcoleDiploma(req, res) {
  try {
    const { diplomaId } = req.params;

    // V√©rifier si le dipl√¥me existe et n'est pas encore valid√©
    const diplome = await prisma.diplomeEcole.findUnique({
      where: { id: parseInt(diplomaId) }
    });

    if (!diplome) {
      return res.status(404).json({ success: false, message: "Dipl√¥me non trouv√©" });
    }

    if (diplome.complete) {
      return res.status(400).json({ 
        success: false, 
        message: "Impossible de supprimer un dipl√¥me d√©j√† valid√© par le minist√®re" 
      });
    }

    // Supprimer le dipl√¥me
    await prisma.diplomeEcole.delete({
      where: { id: parseInt(diplomaId) }
    });

    res.json({ success: true, message: "Dipl√¥me supprim√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
}
,
async getUniversityDiplomas(req, res) {
  try {
    const { universityId } = req.params;
    const { annee, statut } = req.query;

    // Construction de la clause where de base
    const where = {
      etudiant: {
        CursusUniversitaire: {
          some: {
            faculty: {
              idUni: parseInt(universityId)
            }
          }
        }
      }
    };

    // Ajout du filtre par statut si sp√©cifi√©
    if (statut === 'VALIDES') {
      where.complete = true;
    } else if (statut === 'EN_ATTENTE') {
      where.complete = false;
    }

    // Ajout du filtre par ann√©e si sp√©cifi√©
    if (annee) {
      where.dateOfIssue = {
        gte: new Date(`${annee}-01-01`),
        lte: new Date(`${annee}-12-31`)
      };
    }

    const diplomes = await prisma.diplome.findMany({
      where,
      orderBy: { dateOfIssue: 'desc' },
      include: {
        etudiant: {
          select: {
            nom: true,
            prenom: true,
            matricule: true
          }
        }
      }
    });

    res.json(diplomes);
  } catch (error) {
    res.status(500).json({ 
      message: error.message,
      ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    });
  }
},
// Nouvelle route pour supprimer un dipl√¥me d'universit√©
async deleteUniversityDiploma(req, res) {
  try {
    const { diplomaId } = req.params;

    // V√©rifier si le dipl√¥me existe et n'est pas encore valid√©
    const diplome = await prisma.diplome.findUnique({
      where: { id: parseInt(diplomeId) }
    });

    if (!diplome) {
      return res.status(404).json({ success: false, message: "Dipl√¥me non trouv√©" });
    }

    if (diplome.complete) {
      return res.status(400).json({ 
        success: false, 
        message: "Impossible de supprimer un dipl√¥me d√©j√† valid√©" 
      });
    }

    // Supprimer le dipl√¥me
    await prisma.diplome.delete({
      where: { id: parseInt(diplomeId) }
    });

    res.json({ success: true, message: "Dipl√¥me supprim√© avec succ√®s" });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
},
  async getHistorique(req, res) {
    try {
      console.log('Requ√™te historique re√ßue pour user:', req.user.idEtudiant);
      
      if (!req.user?.idEtudiant) {
        console.warn('Acc√®s non autoris√© - idEtudiant manquant');
        return res.status(401).json({ 
          success: false, 
          message: "Authentification requise" 
        });
      }
  
      const historique = await prisma.historiqueVerification.findMany({
        where: { idEtudiant: req.user.idEtudiant },
        distinct: ['titreDiplome'],
        orderBy: { dateDemande: 'desc' }
      });
  
      console.log(`Historique trouv√©: ${historique.length} entr√©es`);
  
      // R√©ponse explicite en JSON
      res.setHeader('Content-Type', 'application/json');
      res.status(200).json({
        success: true,
        historique: historique.map(item => ({
          id: item.id,
          titreDiplome: item.titreDiplome,
          lienVerification: item.lienVerification,
          etablissement: item.etablissement,
          dateDemande: item.dateDemande
        }))
      });
  
    } catch (error) {
      console.error('Erreur getHistorique:', {
        error: error.message,
        stack: error.stack,
        user: req.user
      });
      res.status(500).json({
        success: false,
        message: "Erreur serveur",
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
}
export default DiplomasController;
